<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="css/style.css" type="text/css" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>JS Process Blog</title>
  </head>
  <body class="ogColor">
    <h3>Week 1: 5/13</h3>
    <p class="slim">
      The first week of my JS Independent Study will consist of a brief project
      that includes an editor, a lintor, and a formatter. The editor I chose to
      use is VS Code, the lintor is eslint, and the formatter is prettier. This
      project will also use typescript, sass, and pug.
    </p>
    <p class="slim">
      As of right now I'm still doing research on typescript, sass, and pug. I'm
      not sure exactly what it is I'd like to make but I'll work that out soon.
    </p>
    <p class="slim">
      After a lot of trial/error, not to mention some mistakes in what I chose
      to learn about first. I learned how to configure a linter, a formatter,
      and my code editor. To configure eslint I used airbnb's configs, I also
      used a prettier config for eslint that overrides any airbnb rules that do
      not have anything to do with code quality. Using two sets of configs makes
      it so there aren't conflicts between the linter, which is not very
      opinionated, and prettier, which is quite opinionated.
    </p>
    <p class="slim">
      TypeScript, sass, and pug will be very useful tools when working on bigger
      projects. Pug and Sass are both preprocessers. They allow developers to
      write more terse versions of html, and css respectively. PUG depends
      entirely upon whitespace for the formatting. Sass's syntax is reminiscent
      of JS, it also allows for the introduction of variables which are very
      useful in the increasingly complex stylesheets people are creating. PUG
      and sass utilize 'mixins' which are separate pieces of code that are
      reusable across projects. Mixins also seem like they would be very useful
      when working on commercial projects where it is very important to be
      precise with colors and typefaces.
    </p>
    <p class="slim">
      You can see the very basic exercise I completed using SASS, PUG, and
      TypeScript <a href="week1.html">here</a>.
    </p>
    <h3>Week 2: 6/6</h3>
    <p class="slim">
      This week was all about bundlers, with a little lodash sprinkled on top.
      There are many bundlers out there to choose from. The top three are
      Webpack, Grunt, and Gulp. Webpack leads in popularity by a wide margin
      according to
      <a href="https://2018.stateofjs.com/other-tools/">State of JS</a>.
      Bundlers are enormously powerful programs that can simplify very large
      projects and optimize them for deployment. Webpack even has different
      settings depending on if you're using it in development mode, or
      production mode. For small projects it's a bit too robust, the amount of
      node modules needed for it to work well are numerous. This is definitely
      something that would be very useful for ambitious professional projects.
      If you're interested in sketching this is way too much. I spent the better
      part of a day just getting all the configs set, and sending the bundled
      files to the proper places.
    </p>
    <p class="slim">
      Lodash was also involved in this week's exercise. Albeit only one function
      was called. Based on what I've read lodash is primarily used as a way to
      more quickly parse data and iterate over arrays. Because this project was
      mainly focused on the browser I wasn't able to really dig into the
      functionality of it. The most robust uses of lodash seem to happen when it
      is used in conjunction with node.js.
    </p>
    <p class="slim">
      This week's exercise was deployed using netlify. Click
      <a href="https://dazzling-chandrasekhar-a566c2.netlify.com/">here</a>
      to check it out.
    </p>
    <h3>Week 3: 6/13</h3>
    <p class="slim">
      This Week I fell down the rabbit hole of JS. Rather than starting in the
      simplest possible way I jumped right into using tools that were frankly
      too advanced for me. Rather than beginning this week simply and building
      up to using the more advanced parts of Vue and React I jumped right to
      using tools made for experienced developers. The tools included in both
      the Vue CLI and the React CLI are wonderful for people already familiar
      with how these frameworks behave, when an inexperienced person uses these
      same tools the outcome is chaos.
    </p>
    <p class="slim">
      What is worse is these tools allow a person to get started without needing
      to understand the principals that underpin both Vue and React. This
      further compounds any gaps in one’s knowledge by allowing the user to
      avoid them until they have worked for hours. I was able to create two
      “hello world” examples very quickly using the cli tool kits, but I didn’t
      really have any understanding of what was happening to make this possible.
      When I wanted to make something more complex using these tools it makes
      sense that I was unable to do so.
    </p>
    <p class="slim">
      Here are the two "hello world" examples I created
      <a href="https://14amoore.github.io/reactHello/">React</a> &amp;
      <a href="https://14amoore.github.io/vueHello/">Vue</a>.
    </p>
    <h3>Week 4: 6/20</h3>
    <p class="slim">
      After a rather discouraging week tangling with tools that were simply too
      advanced for me I went back and started learning how to use Vue and React
      in the most basic ways. This was challenging for me. I sometimes feel that
      I have so much to learn and so little time that I want to skip right to
      using the most advanced tools. I’ve learned the same lesson at least once
      per semester this year, always start as simply as you can and only add
      more advanced tools when you have a relatively sure grasp of the concepts
      you’re already using.
    </p>
    <p class="slim">
      Both Vue and React are frameworks designed for building user interfaces.
      React is a Facebook product. Vue was created by Evan You after Google. I
      imagine as sentiment continues to turn on Facebook more and more people
      will begin to seriously consider not using React (or at least that is my
      hope).
    </p>
    <p class="slim">
      React uses JSX while Vue uses templates in its components. This means that
      a Vue developer can write HTML or JSX and the component will be valid,
      rather than React where a developer must us JSX. With Vue I can also use
      Pug, which is a nice. My favorite aspect of Vue, the technical feature
      that makes it more attractive than React, is how it can easily scale down.
      React seems like it is really made for large scale projects. Vue on the
      other hand can be used on very simple single page projects, and huge
      enterprise scale projects, it does both well.
    </p>
    <p class="slim">
      Both of the projects I made for this week deal with the Dead and Co
      concerts I am going to next week. I hope you get a kick out of them.
      <a href="https://14amoore.github.io/vueDead/">vueDead</a> &amp;
      <a href="https://14amoore.github.io/reactDead/">reactDead</a>
    </p>
    <h3>Week 5: 6/27</h3>
    <p class="slim">
      This week I learned about prototypical inheritance and features added to
      JS in the 6th edition of ECMA Script(ES6). I have to say I’m pretty
      relieved about this week. Reading first about prototypical inheritance,
      and then working through the
      <a
        href="https://www.khanacademy.org/computing/computer-programming/programming/object-oriented/pt/object-types"
        >Khan Academy tutorial</a
      >
      that is available for it gave me a much better understanding of how
      inheritance works in JavaScript.
    </p>
    <p class="slim">
      Inheritance is actually one of the most interesting features of JS. Where
      other languages have numerous types of constructs, JS has only one
      construct, Objects. Each object has a private property that holds a link
      to another object called its prototype, this continues until an object
      with null as its prototype is reached. Null has no prototype and acts as
      the final link in the prototype chain. According to what I’ve read many
      people coming from other programming languages view this as a flaw, when
      in fact it is an asset when used properly.
    </p>
    <p class="slim">
      This brings us to JS objects. JS objects are dynamic containers of
      properties, JS objects have a link to the prototype object. When trying to
      access a property of an object the property will be sought on the object
      and the prototype of the object. This will go on until either a property
      with a matching name is found or the end of the inheritance chain is
      reached. In JS any function can be added to an object in the form of a
      property.
    </p>
    <p class="slim">
      ES6 is where a lot of powerful features were added to JS. ES 6 is where
      both const and let where introduced. Before this only var was available to
      assign variables.
    </p>
    <p class="slim">
      Arrow functions are another new and popular feature of ES6. Arrow
      functions allow for shorter syntax when writing functions. The function
      and return keywords are not needed, nor are curly braces. BUT arrow
      functions do not have their own this property. Arrow functions also must
      be declared before they are used, unlike ordinary functions. So, while
      arrow functions are immensely useful they do have some pretty serious
      shortcomings.
    </p>
    <h3>Week 6: 7/4</h3>
    <p class="slim">
      The DOM API and Lodash was the topic for this week’s adventure in
      JavaScript. “The DOM” is a phrase that is thrown around a lot when people
      starting talking about JavaScript. People commonly use the phrase whenever
      talking about displaying information with the browser. For ordinary
      purposes understanding “The DOM” as using the browser to display
      information is fine. This exploration of JavaScript has been anything but
      ordinary.
    </p>
    <p class="slim">
      DOM stands for document object model. MDN
      <a
        class="whiLink"
        href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction"
        >defines</a
      >
      the document object model as “the data representation of the objects that
      comprise the structure and content of a document on the web.”. This is a
      far more nuanced definition of the DOM than is ordinarily implied when
      people are talking about the DOM in everyday conversation.
    </p>
    <p class="slim">
      The document object model allows us to use JavaScript (and other
      programming languages) to connect to the page and change the structure,
      style, and content of the page. This concept is what makes the
      interactivity of the internet possible. Without it we would not be able to
      use languages like JavaScript to make engaging and interesting webpages.
    </p>
    <p class="slim">
      This brings me to the second topic I dove into this week.
      <a class="whiLink" href="https://lodash.com/">Lodash</a>. Lodash is a
      JavaScript library that provides utility functions for routine tasks
      accomplished using JavaScript. In other words it allows people writing
      JavaScript to write more concise code. Lodash also allows programmers to
      use a style of programming called functional programming.
    </p>
    <p class="slim">
      Functional programming is having a bit of a moment in the JavaScript
      world. Functional programming prioritizes pure functions, and shared
      functions. Functional programming strives to avoid shared state, mutating
      state, and side effects. Through this combination of what is emphasized in
      functional programming and what is discouraged it is thought that we have
      much more concise and understandable code. After spending a week
      experimenting with this programming paradigm I definitely agree that it is
      a very effective way of writing code that behaves predictably and is easy
      to maintain.
    </p>
    <p class="slim">
      Lodash itself has been around since 2012, it was inspired by an even older
      library called underscorejs. Due to the popularity of lodash, and
      underscore before it, many of the most popular functions originally only
      available in these libraries have now been adopted by the most recent
      versions of JavaScript. Because of this I had trouble finding cases where
      I absolutely had to have lodash, in most cases plain JavaScript had all
      the functionality I was looking for. Of course, if I was doing a lot of
      data manipulation lodash would most likely have some features that would
      make it very useful.
    </p>
    <h3>Week 7: 7/11</h3>
    <p class="slim">
      I spent this week learning about the Canvas API. “The Canvas API allows
      for graphics to be drawn using JavaScript. This is API is used for
      animation, game graphics, data viz, photo manipulation, and real time
      video processing (this definition is quoted from
      <a
        class="whiLink"
        href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API"
        >MDN web docs.</a
      >)"
    </p>
    <p class="slim">
      I chose to focus on the drawing of graphics, first using WebGL, and then
      using threejs . WebGL is an API used to draw 2D and 3D graphics using
      JavaScript. WebGL uses only points, lines, and triangles to draw. Anything
      can be drawn using points, lines, and triangles, BUT you need an awful lot
      of these basic components to draw anything that is truly interesting.
    </p>
    <p class="slim">
      WebGL is notorious for the large amount of code it requires to render
      relatively simple graphics. After writing over 450 lines of JavaScript and
      many hours following
      <a
        class="whiLink"
        href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL"
        >the MDN tutorial</a
      >
      about WebGL I was able to create
      <a class="whiLink" href="/webGl.html">a 3D cube that rotates</a>, each
      side is a different color, and the cube itself is nicely lit.
    </p>
    <p class="slim">
      Unfortunately writing this much code to produce a simple 3D animation
      would make WebGL a somewhat onerous API to utilize for anything but the
      most simple animations. So why learn anything about WebGL? So I can
      understand what threejs is doing!
    </p>
    <p class="slim">
      <a class="whiLink" href="https://threejs.org/">Threejs</a> is a library
      that sits on top of the WebGL API and makes the API significantly easier
      to use. Threejs does not use WebGL exclusively but it is safe to say WebGL
      is the cornerstone of threejs. Using threejs is was able to make a much
      <a class="whiLink" href="https://adamoore.net/threejs.html"
        >more interesting 3D animation</a
      >
      in about the same amount of time it took me to create a rotating, colorful
      cube using pure WebGL.
    </p>
    <p class="slim"><a class="whiLink" href="index.html"><- Back</a></p>
  </body>
  <script src="js/scripts.js"></script>
</html>
