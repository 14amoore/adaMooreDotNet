<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="css/style.css" type="text/css" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>JS Process Blog</title>
  </head>
  <body class="ogColor">
    <h3>Week 1: 5/13</h3>
    <p class="slim">
      The first week of my JS Independent Study will consist of a brief project
      that includes an editor, a lintor, and a formatter. The editor I chose to
      use is VS Code, the lintor is eslint, and the formatter is prettier. This
      project will also use typescript, sass, and pug.
    </p>
    <p class="slim">
      As of right now I'm still doing research on typescript, sass, and pug. I'm
      not sure exactly what it is I'd like to make but I'll work that out soon.
    </p>
    <p class="slim">
      After a lot of trial/error, not to mention some mistakes in what I chose
      to learn about first. I learned how to configure a linter, a formatter,
      and my code editor. To configure eslint I used airbnb's configs, I also
      used a prettier config for eslint that overrides any airbnb rules that do
      not have anything to do with code quality. Using two sets of configs makes
      it so there aren't conflicts between the linter, which is not very
      opinionated, and prettier, which is quite opinionated.
    </p>
    <p class="slim">
      TypeScript, sass, and pug will be very useful tools when working on bigger
      projects. Pug and Sass are both preprocessers. They allow developers to
      write more terse versions of html, and css respectively. PUG depends
      entirely upon whitespace for the formatting. Sass's syntax is reminiscent
      of JS, it also allows for the introduction of variables which are very
      useful in the increasingly complex stylesheets people are creating. PUG
      and sass utilize 'mixins' which are separate pieces of code that are
      reusable across projects. Mixins also seem like they would be very useful
      when working on commercial projects where it is very important to be
      precise with colors and typefaces.
    </p>
    <p class="slim">
      You can see the very basic exercise I completed using SASS, PUG, and
      TypeScript <a href="week1.html">here</a>.
    </p>
    <h3>Week 2: 6/6</h3>
    <p class="slim">
      This week was all about bundlers, with a little lodash sprinkled on top.
      There are many bundlers out there to choose from. The top three are
      Webpack, Grunt, and Gulp. Webpack leads in popularity by a wide margin
      according to
      <a href="https://2018.stateofjs.com/other-tools/">State of JS</a>.
      Bundlers are enormously powerful programs that can simplify very large
      projects and optimize them for deployment. Webpack even has different
      settings depending on if you're using it in development mode, or
      production mode. For small projects it's a bit too robust, the amount of
      node modules needed for it to work well are numerous. This is definitely
      something that would be very useful for ambitious professional projects.
      If you're interested in sketching this is way too much. I spent the better
      part of a day just getting all the configs set, and sending the bundled
      files to the proper places.
    </p>
    <p class="slim">
      Lodash was also involved in this week's exercise. Albeit only one function
      was called. Based on what I've read lodash is primarily used as a way to
      more quickly parse data and iterate over arrays. Because this project was
      mainly focused on the browser I wasn't able to really dig into the
      functionality of it. The most robust uses of lodash seem to happen when it
      is used in conjunction with node.js.
    </p>
    <p class="slim">
      This week's exercise was deployed using netlify. Click
      <a href="https://dazzling-chandrasekhar-a566c2.netlify.com/">here</a>
      to check it out.
    </p>
    <h3>Week 3: 6/13</h3>
    <p class="slim">
      This Week I fell down the rabbit hole of JS. Rather than starting in the
      simplest possible way I jumped right into using tools that were frankly
      too advanced for me. Rather than beginning this week simply and building
      up to using the more advanced parts of Vue and React I jumped right to
      using tools made for experienced developers. The tools included in both
      the Vue CLI and the React CLI are wonderful for people already familiar
      with how these frameworks behave, when an inexperienced person uses these
      same tools the outcome is chaos.
    </p>
    <p class="slim">
      What is worse is these tools allow a person to get started without needing
      to understand the principals that underpin both Vue and React. This
      further compounds any gaps in one’s knowledge by allowing the user to
      avoid them until they have worked for hours. I was able to create two
      “hello world” examples very quickly using the cli tool kits, but I didn’t
      really have any understanding of what was happening to make this possible.
      When I wanted to make something more complex using these tools it makes
      sense that I was unable to do so.
    </p>
    <p class="slim">
      Here are the two "hello world" examples I created
      <a href="https://14amoore.github.io/reactHello/">React</a> &amp;
      <a href="https://14amoore.github.io/vueHello/">Vue</a>.
    </p>
    <h3>Week 4: 6/20</h3>
    <p class="slim">
      After a rather discouraging week tangling with tools that were simply too
      advanced for me I went back and started learning how to use Vue and React
      in the most basic ways. This was challenging for me. I sometimes feel that
      I have so much to learn and so little time that I want to skip right to
      using the most advanced tools. I’ve learned the same lesson at least once
      per semester this year, always start as simply as you can and only add
      more advanced tools when you have a relatively sure grasp of the concepts
      you’re already using.
    </p>
    <p class="slim">
      Both Vue and React are frameworks designed for building user interfaces.
      React is a Facebook product. Vue was created by Evan You after Google. I
      imagine as sentiment continues to turn on Facebook more and more people
      will begin to seriously consider not using React (or at least that is my
      hope).
    </p>
    <p class="slim">
      React uses JSX while Vue uses templates in its components. This means that
      a Vue developer can write HTML or JSX and the component will be valid,
      rather than React where a developer must us JSX. With Vue I can also use
      Pug, which is a nice. My favorite aspect of Vue, the technical feature
      that makes it more attractive than React, is how it can easily scale down.
      React seems like it is really made for large scale projects. Vue on the
      other hand can be used on very simple single page projects, and huge
      enterprise scale projects, it does both well.
    </p>
    <p class="slim">
      Both of the projects I made for this week deal with the Dead and Co
      concerts I am going to next week. I hope you get a kick out of them.
      <a href="https://14amoore.github.io/vueDead/">vueDead</a> &amp;
      <a href="https://14amoore.github.io/reactDead/">reactDead</a>
    </p>
    <h3>Week 5: 6/27</h3>
    <p class="slim">
      This week I learned about prototypical inheritance and features added to
      JS in the 6th edition of ECMA Script(ES6). I have to say I’m pretty
      relieved about this week. Reading first about prototypical inheritance,
      and then working through the
      <a
        href="https://www.khanacademy.org/computing/computer-programming/programming/object-oriented/pt/object-types"
        >Khan Academy tutorial</a
      >
      that is available for it gave me a much better understanding of how
      inheritance works in JavaScript.
    </p>
    <p class="slim">
      Inheritance is actually one of the most interesting features of JS. Where
      other languages have numerous types of constructs, JS has only one
      construct, Objects. Each object has a private property that holds a link
      to another object called its prototype, this continues until an object
      with null as its prototype is reached. Null has no prototype and acts as
      the final link in the prototype chain. According to what I’ve read many
      people coming from other programming languages view this as a flaw, when
      in fact it is an asset when used properly.
    </p>
    <p class="slim">
      This brings us to JS objects. JS objects are dynamic containers of
      properties, JS objects have a link to the prototype object. When trying to
      access a property of an object the property will be sought on the object
      and the prototype of the object. This will go on until either a property
      with a matching name is found or the end of the inheritance chain is
      reached. In JS any function can be added to an object in the form of a
      property.
    </p>
    <p class="slim">
      ES6 is where a lot of powerful features were added to JS. ES 6 is where
      both const and let where introduced. Before this only var was available to
      assign variables.
    </p>
    <p class="slim">
      Arrow functions are another new and popular feature of ES6. Arrow
      functions allow for shorter syntax when writing functions. The function
      and return keywords are not needed, nor are curly braces. BUT arrow
      functions do not have their own this property. Arrow functions also must
      be declared before they are used, unlike ordinary functions. So, while
      arrow functions are immensely useful they do have some pretty serious
      shortcomings.
    </p>
    <p class="slim"><a href="index.html"><- Back</a></p>
  </body>
  <script src="js/scripts.js"></script>
</html>
